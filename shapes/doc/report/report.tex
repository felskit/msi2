\documentclass[11pt,a4paper]{article}
\usepackage{fullpage}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{float}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage[polish]{babel}
\usepackage{menukeys}

\def\arraystretch{1.5}
\renewcommand{\thesection}{\arabic{section}.}
\renewcommand{\thesubsection}{\thesection\arabic{subsection}.}
\renewcommand{\thesubsubsection}{\thesubsection\arabic{subsubsection}.}
\setlength{\parindent}{0cm}
\setlength{\parskip}{2mm}

\begin{document}

\title{Metody sztucznej inteligencji 2 \\
\Large{
    Projekt 2. --- Rozpoznawanie kształtów w czasie rzeczywistym \\
    Raport końcowy
}}
\author{Bartłomiej Dach \and Tymon Felski}
\maketitle

Poniższy dokument zawiera końcowy opis projektu, którego celem jest zaimplementowanie rozwiązania pozwalającego na~detekcję i~rozpoznawanie prostych kształtów na~obrazach za~pomocą metod geometrycznych oraz z~użyciem sieci neuronowych i~porównanie skuteczności oraz~wydajności obu wariantów.

\section{Opis problemu badawczego}

Zagadnienie rozpoznawania obiektów na~obrazach z~użyciem metod sztucznej inteligencji stanowi duży obszar zainteresowań naukowych.
Efektywne rozwiązanie tego zagadnienia pomogłoby usprawnić wiele procesów, dotychczas wymagających ludzkiej kontroli i~interwencji.

W~niniejszym projekcie zbiór rozpoznawanych typów obiektów został zawężony do~czterech rodzajów kształtów geometrycznych: trójkąta, kwadratu, koła i~gwiazdy pięcioramiennej (patrz rys, \ref{fig:shapes}).
Kształty mogą znajdować się w~dowolnej orientacji i~mieć dowolny rozmiar.
Dla~uproszczenia zakładamy również, że kolor rozpoznawanych obiektów jest jednakowy i~znany \emph{a~priori}.

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.2\textwidth}
        \centering
        \includegraphics[width=\textwidth]{res/img/triangle.png}
    \end{subfigure}
    \begin{subfigure}[t]{0.2\textwidth}
        \centering
        \includegraphics[width=\textwidth]{res/img/square.png}
    \end{subfigure}
    \\
    \begin{subfigure}[t]{0.2\textwidth}
        \centering
        \includegraphics[width=\textwidth]{res/img/star.png}
    \end{subfigure}
    \begin{subfigure}[t]{0.2\textwidth}
        \centering
        \includegraphics[width=\textwidth]{res/img/circle.png}
    \end{subfigure}
    \caption{Przykładowe kształty ze~zbioru treningowego używanego do~treningu i~oceny jakości klasyfikatorów}
    \label{fig:shapes}
\end{figure}

\subsection{Cel badań}

Kształty geometryczne wykazują pewien stopień regularności, co~powoduje, że do~ich rozpoznawania można próbować zastosować algorytmy dokładne.
Przykładem są zaimplementowane w~bibliotece OpenCV \cite{opencv}:
\begin{itemize}
    \item algorytm Suzukiego \cite{suzuki1985} do~wyznaczania konturów na~podstawie obrazów rastrowych,
    \item algorytm Douglasa-Peuckera \cite{douglas1973} do~upraszczania konturów i~redukcji liczby punktów.
\end{itemize}
Dzięki tym dwóm algorytmom można na~podstawie binarnego obrazu wejściowego wyznaczyć kontur kształtu --- łamaną zamkniętą przybliżającą kształt wyznaczony przez piksele kształtu na~tle.

Oprócz metod dokładnych, do~zagadnienia rozpoznawania można również użyć sieci neuronowych, które zamiast wiedzy dokładnej używają przygotowanych zbiorów treningowych oraz metod optymalizacji, aby~dokonać klasyfikacji.
Celem badań jest porównanie wydajności i~skuteczności wybranych metod.

\subsection{Wykorzystane techniki}

Do~zaimplementowania klasyfikatorów użyty został język skryptowy \textbf{Python} w~wersji 3.5.2.
Ponadto wykorzystane zostały dodatkowe biblioteki, wymienione w~tabeli~\ref{tbl:libraries}.
Podejście geometryczne opiera~się na~funkcjach udostępnianych przez \textbf{OpenCV}, podczas gdy sieci neuronowe stworzone zostały za~pośrednictwem API dostarczanego przez bibliotekę \textbf{Keras}.

\begin{table}[H]
    \begin{tabularx}{\textwidth}{|c|l|X|l|c|}
        \hline
        \textbf{Nr} & \textbf{Komponent, wersja} & \textbf{Opis} & \textbf{Licencja} & \\
        \hline
        \hline
        1 &
        h5py, 2.7.1 &
        Interfejs dla binarnego formatu danych HDF5, wymagany przez Keras &
        BSD License &
        \cite{h5py} \\
        \hline
        2 &
        Keras, 2.1.4 &
        Biblioteka udostępniająca API do~sieci neuronowych &
        MIT License &
        \cite{keras} \\
        \hline
        3 & 
        Matplotlib, 2.1.0 & 
        Umożliwia tworzenie wykresów &
        Matplotlib License &
        \cite{matplotlib} \\
        \hline
        4 & 
        NumPy, 1.13.3 &
        Używana do~efektywnych obliczeń na~wektorach $n$-wymiarowych &
        BSD License &
        \cite{numpy} \\
        \hline
        5 & 
        OpenCV, 3.3.0 &
        Biblioteka do~obróbki obrazów &
        New BSD License &
        \cite{opencv} \\
        \hline
        6 &
        pandas, 0.21.0 &
        Wspomaga ładowanie danych z~plików CSV oraz~ich analizę &
        BSD License &
        \cite{pandas} \\
        \hline
        7 &
        TensorFlow, 1.8.0 &
        Framework do~uczenia maszynowego używany przez Keras &
        Apache 2.0 &
        \cite{tensorflow} \\
        \hline
    \end{tabularx}
    \caption{Wykorzystane biblioteki wraz z~określeniem licencji}
    \label{tbl:libraries}
\end{table}

\subsubsection{Wycięcie kształtów z~tła}

Ponieważ projekt zakłada, że kolor kształtów jest zadany z~góry, do~ekstrakcji kształtów z~tła wystarczy zastosować operację progowania obrazu.
Pozwala ona na~zamianę obrazu w~kolorze na~obraz binarny.
Progowanie wykonywane jest w~przestrzeni kolorów HSV, która dobrze odwzorowuje podobieństwo odcieni barw; wystarczy zdefiniować przedział dla~parametru H, który określa sąsiedztwo tonalne żądanego koloru.

\subsubsection{Klasyfikator geometryczny}

Główną ideą działania klasyfikatora geometrycznego jest dopasowanie łamanej zamkniętej do~rozpoznanego kształtu i~analiza kształtu tej łamanej.

Do~odróżniania kształtów wykorzystywana jest przede wszystkim liczba wierzchołków w~wyznaczonym konturze.
Pozwala ona na~proste odróżnienie trójkątów, czworokątów i~dziesięciokątów od~pozostałych kształtów.
Ponadto, dla~każdego kształtu innego niż trójkąt, stosowane~są odpowiednie heurystyki:

\begin{itemize}
    \item W~przypadku kwadratów, sprawdzana jest proporcja wysokości do~szerokości kształtu (powinna być bliska jedności).
    Ponadto bok kwadratu wyznaczany jest na~podstawie pola i~obwodu figury; jeśli dwie wyznaczone wartości nie są bliskie sobie, kształt jest odrzucany.
    \item Rozpoznawanie gwiazd korzysta z~faktu, że wierzchołki parzyste i~nieparzyste gwiazdy znajdują~się w~innych odległościach od~środka figury.
    Zatem, jeśli odchylenie standardowe odległości od~środka wierzchołków parzystych i nieparzystych jest zbyt duże, figura jest odrzucana.
    \item Dla~kół, podobnie jak dla~kwadratów, promień koła wyznaczany jest dwukrotnie na~podstawie pola i~obwodu figury.
    W~przypadku zbyt dużej różnicy kształt nie jest klasyfikowany.
\end{itemize}

\subsubsection{Klasyfikatory oparte na~sieciach neuronowych}

Klasyfikatory oparte na~sieciach były trenowane na~podstawie zbioru treningowego \cite{shapes}.
Zostały opracowane dwa warianty sieci, operujące na~obrazie wejściowym rozmiarów $64 \times 64$:

\begin{itemize}
    \item W~pierwszym wariancie wejściowy binarny obraz dwuwymiarowy spłaszczany jest do~jednowymiarowego wektora, który przekazywany jest na~wejście sieci.
    Użyta sieć korzysta z~trzech warstw ukrytych z~funkcją aktywacji ReLU (ang. \emph{Rectified Linear Unit}).
    Ponadto, po~każdej warstwie ukrytej dodana jest warstwa \emph{dropout}, zapobiegająca zjawisku \emph{overfitting} \cite{srivastava2014}.

    Warstwa wyjściowa jako funkcji aktywacji używa funkcji \emph{softmax}.
    \item Drugi wariant korzysta z~pojedynczej warstwy konwolucyjnej z~rozmiarem okna $8 \times 8$ oraz warstwy \emph{dropout}.
    Wynik warstwy konwolucyjnej jest spłaszczany i~dostarczany do~warstwy wyjściowej z~funkcją \emph{softmax}.
\end{itemize}

\section{Instrukcja użytkowania}

W~skład projektu wchodzą trzy główne skrypty Pythona, odpowiadające kolejno za~trenowanie klasyfikatorów opartych na~sieciach neuronowych i~testowanie działania wszystkich trzech klasyfikatorów na~obrazach statycznych oraz strumieniach wideo z~kamery komputera. 

\subsection{Trenowanie sieci neuronowej}

Do~wykonania treningu sieci neuronowej należy wykorzystać skrypt \verb+train.py+.
Dokonuje on wyznaczenia modelu dla~sieci w~obu wariantach (spłaszczonym i~konwolucyjnym).
Skrypt należy wywołać poleceniem
\begin{verbatim}
$ python train.py -d train-image-directory
\end{verbatim}
gdzie \verb+train-image-directory+ oznacza katalog zawierający zbiór treningowy udostępniony w~\cite{shapes}.
Obrazy w~zbiorze treningowym muszą zawierać czarne kształty na~białym tle.

Wykonanie skryptu rozpocznie proces uczenia sieci, który może potrwać do~kilkunastu minut.
W~wyniku działania skryptu w~bieżącym katalogu zostanie stworzony podkatalog \verb+model+, zawierający dwa pliki:

\begin{itemize}
    \item Plik \verb+shapes_model_1d_vec.h5+ zawiera model dla~sieci neuronowej operującej na~spłaszczonym obrazie.
    \item Plik \verb+shapes_model_2d_img.h5+ zawiera model dla~konwolucyjnej sieci neuronowej.
\end{itemize}

\subsection{Testy na~obrazach wczytywanych z~pliku}

Klasyfikacji dla~folderu zawierającego obrazy można wykonać za~pomocą skryptu \verb+image_test.py+.
Skrypt ten wczyta wszystkie obrazy (z białymi kształtami na~czarnym tle) znajdujące~się w~danym folderze i~dokona ich zbiorczej identyfikacji.
Do~uruchomienia go należy użyć polecenia
\begin{verbatim}
$ python image_test.py -d test-image-directory
                       -c {geometric,vector-network,convolutional-network}
\end{verbatim}

\begin{itemize}
    \item W~parametrze \verb+-d+ podajemy ścieżkę do~folderu, w~którym znajdują~się obrazy testowe.
    \item Parametr \verb+-c+ służy wyborowi klasyfikatora, który powinien być użyty dla~danych testowych.
    Możliwe opcje to:
    \begin{itemize}
        \item \verb+geometric+ --- używa klasyfikatora geometrycznego,
        \item \verb+vector-network+ --- używa klasyfikatora opartego o~płaską sieć neuronową,
        \item \verb+convolutional-network+ --- używa klasyfikatora opartego o~sieć konwolucyjną.
    \end{itemize}
\end{itemize}

Na~wyjściu program wypisze liczbę rozpoznanych kształtów każdego rodzaju na~wszystkich obrazach znajdujących~się w~wyspecyfikowanym katalogu.

\subsection{Rozpoznawanie kształtów w~czasie rzeczywistym}

Ostatni skrypt, \verb+capture.py+, służy demonstracji działania klasyfikatorów na~strumieniu wideo.
Obraz pobierany jest z~kamerki komputera, jeśli taką posiada.
Skrypt uruchamiamy bez parametrów poleceniem:
\begin{verbatim}
$ python capture.py
\end{verbatim}
Skrypt ma~charakter interaktywnego okna --- za~pomocą klawiszy klawiatury można przełączać~się między klasyfikatorami lub dokonać próby czasowej.
Dokładny opis wszystkich opcji znajduje~się poniżej.

\begin{itemize}
    \item Klawisze numeryczne służą przełączaniu~się między klasyfikatorami, których wyniki wyświetlane~są na~podglądzie.
    \begin{itemize}
        \item Klawisz \keys{1} powoduje przełączenie podglądu na~klasyfikator geometryczny.
        \item Klawisz \keys{2} powoduje przełączenie podglądu na~wektorowy klasyfikator z~siecią neuronową.
        \item Klawisz \keys{3} powoduje przełączenie podglądu na~klasyfikator z~konwolucyjną siecią neuronową.
    \end{itemize}
    \item Za~pomocą skryptu można wykonać próbę czasową wszystkich klasyfikatorów dla~ustalonego rodzaju kształtu.
    Dla~każdego klasyfikatora liczony jest czas poprawnej klasyfikacji.
    Czas zatrzymywany jest, jeśli klasyfikator przez dłużej niż~24~klatki (1~sekundę) nie~rozpoznaje kształtu lub~rozpoznaje go~błędnie.
    \begin{itemize}
        \item Klawisze \keys{Z}, \keys{X}, \keys{C}, \keys{V} ustawiają docelowy rodzaj kształtu.
        \begin{itemize}
            \item Wciśnięcie klawisza \keys{Z} oznacza, że rozpoznawane będą kwadraty.
            \item Wciśnięcie klawisza \keys{X} oznacza, że rozpoznawane będą gwiazdy.
            \item Wciśnięcie klawisza \keys{C} oznacza, że rozpoznawane będą koła.
            \item Wciśnięcie klawisza \keys{V} oznacza, że rozpoznawane będą trójkąty.
        \end{itemize}
        \item Klawisz \keys{A} powoduje rozpoczęcie liczenia czasu.
        \item Klawisz \keys{S} powoduje zatrzymanie rozpoczętej próby.
        \item Klawisz \keys{R} powoduje zrestartowanie próby.
    \end{itemize}
    Podczas trwania próby można zarówno zmieniać docelowy typ rozpoznawanego kształtu, jak i~przełączać podgląd wyników klasyfikatora między dostępnymi opcjami.
    \item Klawisz \keys{H} powoduje wyświetlenie pomocy na~ekranie.
    \item Klawisz \keys{D} powoduje włączenie trybu \emph{debug}.
    W~tym trybie w~osobnych oknach na~ekranie wyświetlane~są rozpoznawane po~progowaniu kontury, a na~konsoli wyświetlane są: średni, minimalny i maksymalny czas działania poszczególnych klasyfikatorów.
    \item Klawisz \keys{Q} powoduje zakończenie działania skryptu.
\end{itemize}

\section{Wyniki eksperymentalne}

\subsection{Kryteria oceny klasyfikatorów}

\subsection{Uzyskane wyniki}

\section{Podsumowanie}

\subsection{Możliwości dalszych badań}

\begin{thebibliography}{99}

    \bibitem{bishop1995}
        C.M. Bishop:
        \emph{Neural Networks for~Pattern Recognition}.
        Oxford University Press:
        Nowy Jork,
        1995.

    \bibitem{keras}
        F. Chollet, Keras Team:
        Keras -- Deep Learning for humans. \\
        Oficjalna strona: \url{https://keras.io}
        [Dostęp 17~marca 2018]

    \bibitem{h5py}
        A. Collette,
        HDF5 for Python. \\
        Oficjalna strona: \url{https://www.h5py.org/}
        [Dostęp 27~maja 2018]
        
    \bibitem{douglas1973}
        D.H. Douglas,
        T.K. Peucker,
        ,,Algorithms for the Reduction of~the~Number of~Points Required to~Represent a~Digitized Line or its Caricature'',
        \emph{Cartographica: The International Journal for Geographic Information and~Geovisualization},
        tom 10,
        s. 112--122,
        1973.

    \bibitem{opencv}
        Intel Corporation, Willow Garage, Itseez:
        OpenCV -- Open Source Computer Vision. \\
        Oficjalna strona: \url{https://opencv.org}.
        [Dostęp 17~marca 2018]

    \bibitem{matplotlib}
        Matplotlib Development Team:
        Matplotlib. \\
        Oficjalna strona: \url{https://matplotlib.org}.
        [Dostęp 17~marca 2018]

    \bibitem{pandas}
        W. McKinney:
        pandas -- Python Data Analysis Library. \\
        Oficjalna strona: \url{https://pandas.pydata.org}.
        [Dostęp 17~marca 2018]

    \bibitem{shapes}
        S. Meschke:
        Four Shapes dataset. \\
        Dostępny: \url{https://www.kaggle.com/smeschke/four-shapes}.
        [Dostęp 17~marca 2018]

    \bibitem{murty2015}
        M.N. Murty,
        V.S. Devi:
        \emph{Introduction to~Pattern Recognition and~Machine Learning}.
        World Scientific Publishing:
        Singapur,
        2015.

    \bibitem{numpy}
        T. Oliphant:
        NumPy. \\
        Oficjalna strona: \url{http://www.numpy.org}.
        [Dostęp 17~marca 2018]
        
    \bibitem{srivastava2014}
        N. Srivastava,
        G. Hinton,
        A. Krizhevsky,
        I. Sutskever,
        R. Salakhutdinov,
        ,,Dropout: A Simple Way to Prevent Neural Networks from Overfitting'',
        \emph{Journal of Machine Learning Research},
        tom 15,
        s.~1929--1958,
        2014.

    \bibitem{suzuki1985}
        S. Suzuki,
        K. Abe,
        ,,Topological structural analysis of~digitized binary images''
        \emph{Computer Vision, Graphics and~Image Processing},
        tom 30,
        s.~32--66,
        1985.

    \bibitem{tensorflow}
        TensorFlow Team:
        TensorFlow -- An open source machine learning framework for everyone. \\
        Oficjalna strona: \url{https://www.tensorflow.org/}
        [Dostęp 27~maja 2018]

\end{thebibliography}

\end{document}